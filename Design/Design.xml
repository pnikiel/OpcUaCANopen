<?xml version="1.0" encoding="UTF-8"?>
<d:design xmlns:d="http://cern.ch/quasar/Design" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" projectShortName="OpcUaNewCANopenServer" xsi:schemaLocation="http://cern.ch/quasar/Design Design.xsd " author="Piotr Nikiel (ATLAS Central DCS)">
  <d:class name="GlobalSettings">
    <d:devicelogic/>
    <d:configentry dataType="UaString" name="spyMode" defaultValue="suggestFalse" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="enforceTrue"/>
          <d:enumerationValue value="suggestFalse"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
      <d:documentation>enforceTrue enables spy mode on all buses declared in the configuration. See FC4.1 for exact documentation of the spy mode feature.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Double" name="expeditedSdoTimeoutSeconds" defaultValue="2" storedInDeviceObject="true">
      <d:documentation>
  			Max time between SDO request (from server) and SDO reply (from a CANopen node) that is
  			permissible; otherwise a timeout condition is considered.
  		</d:documentation>
      <d:configRestriction>
        <d:restrictionByBounds minInclusive="0.001"/>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="OpcUa_Float" name="nodeGuardingReplyTimeout" defaultValue="1" storedInDeviceObject="true">
      <d:documentation>
    		Max wait time (in seconds) for NodeGuarding reply after NodeGuarding request, when passed
    		NodeGuarding timeout is declared.
    	</d:documentation>
    </d:configentry>
    <d:documentation>GlobalSettings is a collection of settings per whole server instance.</d:documentation>
  </d:class>
  <d:class name="Warnings">
    <d:devicelogic/>
    <d:configentry dataType="OpcUa_Boolean" name="rxFromUnknownNode" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>Warn when receiving messages from undeclared node.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="stateToggleViolation" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>Warn on state toggle violation.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="tpdoSyncMismatch" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>Warn when not receiving data after sync, or receiving too much data after sync, for TPDOs configured onSync.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="tpdoTooShort" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>Warn when received TPDO is too short.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="unexpectedNmt" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>
            Warn when receiving NMT Control which come from 3rd party masters.
        </d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="unexpectedSync" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>
            Warn when receiving SYNC which come from 3rd party masters.
        </d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="unexpectedTpdo" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>
  			Warn when receiving TPDOs which are not expected per configuration.
  		</d:documentation>
    </d:configentry>
  </d:class>
  <d:class name="Bus">
    <d:devicelogic/>
    <d:hasobjects instantiateUsing="configuration" class="Node"/>
    <d:configentry dataType="UaString" name="provider" storedInDeviceObject="true">
      <d:documentation>CanModule implementation type name.
			The following known implementations are listed below (note, some implementations are operating system dependent
			or may be disabled from the build process):
			<ul><li>sock - Linux only, standard Linux SocketCAN interface. Works with VCAN, Systec (systec_can driver), Peak and other SocketCAN compatible interfaces.</li><li>an - Linux+Windows, Anagate Ethernet-CAN bridges from the Analytica company.</li></ul>
			</d:documentation>
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="sock"/>
          <d:enumerationValue value="an"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="port" storedInDeviceObject="true">
      <d:documentation>
				CAN port identifier in the system, which will be opened
				using the provider (see provider attribute). Is
				provider-dependent though standardized names (e.g. "0",
				"1") work for most providers. When using "sock" provider in Linux, it is common to use full port names (e.g. can0) instead of the numbers.
				
			</d:documentation>
    </d:configentry>
    <d:configentry dataType="UaString" name="settings">
      <d:configRestriction>
        <d:restrictionByPattern pattern="50k|125k|250k|DontConfigure"/>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="spyMode" defaultValue="inheritFromGlobalSettings">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="true"/>
          <d:enumerationValue value="false"/>
          <d:enumerationValue value="inheritFromGlobalSettings"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
      <d:documentation>
    		When activated (i.e. true, or inheriting true from global settings) the server will never
    		transmit anything on that particular bus and will listen only. This mode is useful

    	</d:documentation>
    </d:configentry>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Int16" name="portError" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
		</d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaString" name="portErrorDescription" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
		</d:cachevariable>
    <d:cachevariable initializeWith="configuration" dataType="OpcUa_UInt32" name="syncIntervalMs" nullPolicy="nullForbidden" addressSpaceWrite="regular">
      <d:documentation>Sync cycle period in miliseconds. For average DCS systems, typical values are between 1000 and 60000. 0 indicates that SYNC is disabled.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="configuration" dataType="OpcUa_Double" name="nodeGuardInterval" nullPolicy="nullForbidden" addressSpaceWrite="delegated">
      <d:documentation>The NG interval in seconds for all nodes configured for NodeGuarding. 10 is a typical value.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="statsTotalTransmitted" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="statsTotalReceived" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Double" name="statsTxRate" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Double" name="statsRxRate" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="statsTransitionsIntoErrorCounter" nullPolicy="nullForbidden" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good" initialValue="0">
    </d:cachevariable>
  </d:class>
  <d:class name="Node">
    <d:devicelogic>
      <d:mutex/>
    </d:devicelogic>
    <d:configentry dataType="OpcUa_Byte" name="id" isKey="true" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByBounds minInclusive="1"/>
      </d:configRestriction>
      <d:documentation>CANopen node id. Typically configured by switches or jumpers on the actual hardware.</d:documentation>
    </d:configentry>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="bootupCounter" nullPolicy="nullForbidden" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good" initialValue="0">
      <d:documentation>Number of bootup messages that the server from the node since server's start-up.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="state" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>CANopen state of the node understood as what node-guarding returns (toggling is not filtered out).</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="stateNoToggle" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>TODO me ;-)</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaString" name="stateAsText" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>CANopen state, enhanced with DISCONNECTED and UNKNOWN state, shown as text, one of:
			<ul><li>STOPPED - online but intentionally stopped. Not replying to SDOs and PDOs.</li><li>PREOPERATIONAL - preoperational. Replying to SDOs but not performing any PDO info exchange.</li><li>OPERATIONAL - in full operation</li><li>DISCONNECTED - node not responding while the server believes that the infrastructure (especially the CAN interface) is alright</li><li>UNKNOWN - the state is not known due to identified issues, e.g. CAN interface down or so.</li></ul>
			</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="configuration" dataType="UaString" name="requestedState" nullPolicy="nullForbidden" addressSpaceWrite="delegated">
      <d:documentation>
			Specifies the intended state of a node. Is applicable both for configuration (then it specifies the initial state that the node should be brought into)
			as well as in the usual runtime (then it can be used to control the state).
			</d:documentation>
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="OPERATIONAL"/>
          <d:enumerationValue value="PREOPERATIONAL"/>
          <d:enumerationValue value="STOPPED"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:cachevariable>
    <d:method name="reset" executionSynchronicity="asynchronous" addressSpaceCallUseMutex="of_containing_object">
      <d:returnvalue dataType="OpcUa_Boolean" name="bootupReceived"/>
      <d:documentation>
    		Attempts node reset by sending NMT request. Will return success if the node replied within
    		bootup message. Otherwise will fail.
    	</d:documentation>
    </d:method>
    <d:hasobjects instantiateUsing="configuration" class="Tpdo"/>
    <d:hasobjects instantiateUsing="configuration" class="TpdoMultiplex"/>
    <d:hasobjects instantiateUsing="configuration" class="Rpdo">
</d:hasobjects>
    <d:hasobjects instantiateUsing="configuration" class="SdoSameIndexGroup"/>
    <d:hasobjects instantiateUsing="configuration" class="SdoVariable">
</d:hasobjects>
    <d:hasobjects instantiateUsing="design" class="EmergencyParser">
      <d:object name="Emergency"/>
    </d:hasobjects>
    <d:hasobjects instantiateUsing="configuration" class="OnlineConfigValidator" maxOccurs="1"/>
    <d:hasobjects instantiateUsing="configuration" class="SdoValidator"/>
    <d:configentry dataType="UaString" name="stateInfoSource" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="NodeGuard"/>
          <d:enumerationValue value="HeartBeat"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="stateToggleViolationCounter" nullPolicy="nullForbidden" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good" initialValue="0">
    </d:cachevariable>
    <d:configentry dataType="UaString" name="emergencyMappingModel" defaultValue="ELMBio">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="ELMBio"/>
          <d:enumerationValue value="CANopen"/>
          <d:enumerationValue value="None"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:sourcevariable dataType="OpcUa_UInt32" name="nmtPartialBackwardsCompat" addressSpaceRead="forbidden" addressSpaceReadUseMutex="no" addressSpaceWrite="asynchronous" addressSpaceWriteUseMutex="of_containing_object">
      <d:documentation>This variable is for ensuring *partial compatibility* with the Slava's CANopen OPCUA server -- see FN4.1 in the Piotr's writeup for docs.</d:documentation>
    </d:sourcevariable>
  </d:class>
  <d:class name="EmergencyParser">
    <d:devicelogic/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt16" name="lastErrorCode" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaString" name="lastErrorDescription" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
</d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorRegister" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte3" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte4" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte5" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte6" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte7" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="emergencyErrorCounter" nullPolicy="nullForbidden" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good" initialValue="0">
</d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaString" name="lastEmergencyErrorBundle" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData" initialValue="">
    </d:cachevariable>
  </d:class>
  <d:class name="Tpdo">
    <d:devicelogic>
      <d:mutex/>
    </d:devicelogic>
    <d:hasobjects instantiateUsing="configuration" class="ExtractedValue"/>
    <d:configentry dataType="OpcUa_Byte" name="selector" isKey="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="1"/>
          <d:enumerationValue value="2"/>
          <d:enumerationValue value="3"/>
          <d:enumerationValue value="4"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="transportMechanism">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="sync"/>
          <d:enumerationValue value="asyncSupportsRtr"/>
          <d:enumerationValue value="publieCommeRecu"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:sourcevariable dataType="OpcUa_UInt32" name="invokeRtr" addressSpaceRead="asynchronous" addressSpaceReadUseMutex="of_containing_object" addressSpaceWrite="asynchronous" addressSpaceWriteUseMutex="of_containing_object">
      <d:documentation>Writing to this variable invokes the RTR for this TPDO. It is a compatibility mode for WinCC OA which can not do method calls. Reading from this variable returns number of times the RTR was invoked in this way.</d:documentation>
    </d:sourcevariable>
  </d:class>
  <d:class name="TpdoMultiplex">
    <d:devicelogic/>
    <d:configentry dataType="OpcUa_Byte" name="selector" isKey="true">
      <d:documentation>
  			The selector code of the TPDO, for TPDO3 it should be 3,
  			etc.
  		</d:documentation>
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="1"/>
          <d:enumerationValue value="2"/>
          <d:enumerationValue value="3"/>
          <d:enumerationValue value="4"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="transportMechanism" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="sync"/>
          <d:enumerationValue value="asyncWithRtr"/>
          <d:enumerationValue value="publieCommeRecu"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:hasobjects instantiateUsing="configuration" class="MultiplexedChannel"/>
    <d:hasobjects instantiateUsing="configuration" class="MultiplexedChannelConfigurationGenerator"/>
  </d:class>
  <d:class name="Rpdo">
    <d:devicelogic>
      <d:mutex/>
    </d:devicelogic>
    <d:configentry dataType="OpcUa_Byte" name="selector" isKey="true">
      <d:documentation>
            The selector code of the RPDO, for RPDO1 it should be 1,
            etc.
        </d:documentation>
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="1"/>
          <d:enumerationValue value="2"/>
          <d:enumerationValue value="3"/>
          <d:enumerationValue value="4"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaByteString" name="cache" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good">
    </d:cachevariable>
    <d:hasobjects instantiateUsing="configuration" class="RpdoCachedVariable"/>
  </d:class>
  <d:class name="RpdoCachedVariable" singleVariableNode="true">
    <d:devicelogic/>
    <d:sourcevariable dataType="UaVariant" name="value" addressSpaceRead="asynchronous" addressSpaceReadUseMutex="of_parent_of_containing_object" addressSpaceWrite="asynchronous" addressSpaceWriteUseMutex="of_parent_of_containing_object">
  	</d:sourcevariable>
    <d:configentry dataType="UaString" name="dataType" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="Boolean"/>
          <d:enumerationValue value="Byte"/>
          <d:enumerationValue value="UInt16"/>
          <d:enumerationValue value="Int16"/>
          <d:enumerationValue value="UInt32"/>
          <d:enumerationValue value="Int32"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="OpcUa_Byte" name="offset" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByBounds maxInclusive="7"/>
      </d:configRestriction>
      <d:documentation>
  			Position in the RPDO payload to be sent at which this variable is mapped.
  		</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Byte" name="booleanToBit" storedInDeviceObject="true" defaultValue="0">
      <d:configRestriction>
        <d:restrictionByBounds maxInclusive="7"/>
      </d:configRestriction>
      <d:documentation>If Boolean, specifies to which bit the boolean applies</d:documentation>
    </d:configentry>
  </d:class>
  <d:class name="OnlineConfigValidator">
    <d:devicelogic/>
    <d:hasobjects instantiateUsing="configuration" class="SdoValidator"/>
    <d:method name="validate" executionSynchronicity="asynchronous">
      <d:returnvalue dataType="UaString" name="details">
        <d:array/>
      </d:returnvalue>
      <d:returnvalue dataType="OpcUa_Boolean" name="passed"/><d:returnvalue dataType="OpcUa_UInt32"
      	name="numberOfFailures">
</d:returnvalue>
    </d:method>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="failuresNumberLastRun"
    	nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
    </d:cachevariable>
  </d:class>
  <d:class name="MultiplexedChannel">
    <d:devicelogic/>
    <d:configentry dataType="OpcUa_UInt16" name="id" isKey="true"/>
    <d:hasobjects instantiateUsing="configuration" class="ExtractedValue"/>
  </d:class>
  <d:class name="ExtractedValue" singleVariableNode="true">
    <d:devicelogic/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaVariant" name="value" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
  	</d:cachevariable>
    <d:configentry dataType="UaString" name="dataType" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="Boolean"/>
          <d:enumerationValue value="Byte"/>
          <d:enumerationValue value="UInt32"/>
          <d:enumerationValue value="Int32"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="OpcUa_Byte" name="offset" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByBounds maxInclusive="7"/>
      </d:configRestriction>
      <d:documentation>
  			At which octet in the data of the received TPDO frame this
  			value starts?
  		</d:documentation>
    </d:configentry>
    <d:configentry dataType="UaString" name="booleanFromBit" defaultValue="-" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="0|1|2|3|4|5|6|7|-"/>
      </d:configRestriction>
    </d:configentry>
  </d:class>
  <d:class name="MultiplexedChannelConfigurationGenerator">
    <d:hasobjects instantiateUsing="configuration" class="MultiplexedChannel"/>
    <d:configentry dataType="OpcUa_Byte" name="numberOfChannels"/>
  </d:class>
  <d:class name="SdoSameIndexGroup">
    <d:devicelogic/>
    <d:hasobjects instantiateUsing="configuration" class="SdoVariable"/>
    <d:configentry dataType="UaString" name="index">
      <d:configRestriction>
        <d:restrictionByPattern pattern="[0-9A-F]{1,4}"/>
      </d:configRestriction>
    </d:configentry>
  </d:class>
  <d:class name="SdoVariable" singleVariableNode="true">
    <d:devicelogic/>
    <d:configentry dataType="UaString" name="index" defaultValue="fromGroup" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="fromGroup|[0-9A-F]{1,4}"/>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="OpcUa_Byte" name="subIndex">
      <d:configRestriction>
        <d:restrictionByPattern pattern="[0-9A-F]{1,4}"/>
      </d:configRestriction>
      <d:documentation>subIndex is decimal!</d:documentation>
    </d:configentry>
    <d:configentry dataType="UaString" name="dataType" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="Boolean"/>
          <d:enumerationValue value="Byte"/>
          <d:enumerationValue value="UInt16"/>
          <d:enumerationValue value="UInt32"/>
          <d:enumerationValue value="Int32"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="access" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="R|RW|W"/>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="booleanFromBit" defaultValue="-" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="0|1|2|3|4|5|6|7|-"/>
      </d:configRestriction>
    </d:configentry>
    <d:sourcevariable dataType="UaVariant" name="value" addressSpaceRead="asynchronous" addressSpaceReadUseMutex="no" addressSpaceWrite="asynchronous" addressSpaceWriteUseMutex="no">
</d:sourcevariable>
  </d:class>
  <d:class name="SdoValidator">
    <d:devicelogic/>
    <d:method name="validate" executionSynchronicity="asynchronous">
      <d:returnvalue dataType="OpcUa_Boolean" name="passed"/>
    </d:method>
    <d:configentry dataType="UaString" name="assertTrueFormula" storedInDeviceObject="true"/>
    <d:configentry name="description" dataType="UaString" storedInDeviceObject="true"/>
  </d:class>
  <d:root>
    <d:hasobjects instantiateUsing="configuration" class="GlobalSettings" maxOccurs="1" minOccurs="1"/>
    <d:hasobjects instantiateUsing="configuration" class="Warnings"/>
    <d:hasobjects instantiateUsing="configuration" class="Bus"/>
  </d:root>
</d:design>
