<?xml version="1.0" encoding="UTF-8"?>
<d:design xmlns:d="http://cern.ch/quasar/Design" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" projectShortName="OpcUaNewCANopenServer" xsi:schemaLocation="http://cern.ch/quasar/Design Design.xsd " author="Piotr Nikiel (ATLAS Central DCS)">
  <d:class name="GlobalSettings" defaultInstanceName="GlobalSettings">
    <d:devicelogic/>
    <d:configentry dataType="UaString" name="spyMode" defaultValue="suggestFalse" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="enforceTrue"/>
          <d:enumerationValue value="suggestFalse"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
      <d:documentation>enforceTrue enables spy mode on all buses declared in the configuration. See FC4.1 for exact documentation of the spy mode feature.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Double" name="expeditedSdoReadTimeoutSeconds" defaultValue="1" storedInDeviceObject="true">
      <d:documentation>
  			Max time between SDO read request (from server) and SDO reply (from a CANopen node) that is
  			permissible; otherwise a timeout condition is raised.
  		</d:documentation>
      <d:configRestriction>
        <d:restrictionByBounds minInclusive="0.001"/>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="OpcUa_Double" name="expeditedSdoWriteTimeoutSeconds" defaultValue="2" storedInDeviceObject="true">
      <d:documentation>
  			Max time between SDO write request (from server) and SDO reply (from a CANopen node) that is
  			permissible; otherwise a timeout condition is raised.
  		</d:documentation>
      <d:configRestriction>
        <d:restrictionByBounds minInclusive="0.001"/>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="OpcUa_Float" name="nodeGuardingReplyTimeout" defaultValue="1" storedInDeviceObject="true">
      <d:documentation>
    		Max wait time (in seconds) for NodeGuarding reply after NodeGuarding request, when passed
    		NodeGuarding timeout is declared.
    	</d:documentation>
    </d:configentry>
    <d:configentry name="asyncPeriodicRtrPeriodSeconds" dataType="OpcUa_UInt32" defaultValue="61" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByBounds minInclusive="10" />
      </d:configRestriction>
      <d:documentation>
        When Periodic-RTR feature is used (that applies mostly to TPDO configuration), this setting determines how often a RTR is emitted.
        See FP6.3: Periodic RTR.
      </d:documentation>
    </d:configentry>
    <d:configentry name="heartBeatWindowSeconds" dataType="OpcUa_UInt32" defaultValue="5" storedInDeviceObject="true">
    </d:configentry>
    <d:documentation>GlobalSettings is a collection of settings per whole server instance.</d:documentation>
  </d:class>
  <d:class name="Warnings" defaultInstanceName="Warnings">
    <d:devicelogic/>
    <d:configentry dataType="OpcUa_Boolean" name="rxFromUnknownNode" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>Warn when receiving messages from undeclared node.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="stateToggleViolation" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>Warn on state toggle violation.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="tpdoSyncMismatch" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>Warn when not receiving data after sync, or receiving too much data after sync, for TPDOs configured onSync.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="tpdoTooShort" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>Warn when received TPDO is too short.</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="unexpectedNmt" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>
            Warn when receiving NMT Control which come from 3rd party masters.
        </d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="unexpectedSync" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>
            Warn when receiving SYNC which come from 3rd party masters.
        </d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Boolean" name="unexpectedTpdo" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>
  			Warn when receiving TPDOs which are not expected per configuration.
  		</d:documentation>
    </d:configentry>
    <d:configentry name="unknownCobid" dataType="OpcUa_Boolean" defaultValue="true" storedInDeviceObject="true">
      <d:documentation>
        Warn when seeing Cobids which are clearly unknown/unregistered.
      </d:documentation>
    </d:configentry>
  </d:class>
  <d:class name="Meta">
    <d:cachevariable name="productVersion" addressSpaceWrite="forbidden" dataType="UaString" initializeWith="valueAndStatus" nullPolicy="nullAllowed" initialStatus="OpcUa_BadWaitingForInitialData"/>
  </d:class>
  <d:class name="Bus">
    <d:devicelogic/>
    <d:hasobjects instantiateUsing="configuration" class="Node"/>
    <d:configentry dataType="UaString" name="provider" storedInDeviceObject="true">
      <d:documentation>CanModule implementation type name.
			  The following known implementations are listed below (note, some implementations are operating system dependent or may be disabled from the build process):
			</d:documentation>
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="sock">
            <d:documentation>SocketCAN (Linux only). Supports VCAN (Linux native virtual CAN driver), SysTec (with dedicated drivers, e.g. ATLAS RPMs) and PEAK (with standard drivers) under Linux.</d:documentation>
          </d:enumerationValue>
          <d:enumerationValue value="an">
            <d:documentation>Anagate Ethernet-CAN bridges from the Analytica company (Linux and Windows).</d:documentation>
          </d:enumerationValue>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="port" storedInDeviceObject="true" isKey="true">
      <d:documentation>
				CAN port identifier in the system, which will be opened
				using the provider (see provider attribute). Is
				provider-dependent though standardized names (e.g. "0",
				"1") work for most providers. When using "sock" provider in Linux, it is common to use full port names (e.g. can0) instead of the numbers.
				
			</d:documentation>
    </d:configentry>
    <d:configentry dataType="UaString" name="settings">
      <d:configRestriction>
        <d:restrictionByPattern pattern="50k|100k|125k|250k|DontConfigure"/>
      </d:configRestriction>
      <d:documentation>
        Bitrate of the CAN interface. The special value <i>DontConfigure</i> indicates preserving the current port state, which is especially useful if elevated privileges would be needed.
      </d:documentation>
    </d:configentry>
    <d:configentry dataType="UaString" name="spyMode" defaultValue="inheritFromGlobalSettings">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="true"/>
          <d:enumerationValue value="false"/>
          <d:enumerationValue value="inheritFromGlobalSettings"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
      <d:documentation>
    		When activated (i.e. true, or inheriting true from global settings) the server will never
    		transmit anything on that particular bus and will listen only. This mode is useful for debugging/development. See FC4.1 in Piotr's write-up.

    	</d:documentation>
    </d:configentry>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="portError" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>Zero when port is believed to be in perfect operational condition (equivalent to OK in CAN status) and non-zero for ERROR_ACTIVE, ERROR_PASSIVE, BUS_OFF or their variants. Null when provider or port does not support or can't report its state (e.g. for VCAN interface).</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaString" name="portErrorDescription" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>Textual description of the port status; might be provider-dependent.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="configuration" dataType="OpcUa_UInt32" name="syncIntervalMs" nullPolicy="nullForbidden" addressSpaceWrite="regular">
      <d:documentation>Sync cycle period in miliseconds. For average DCS systems, typical values are between 1000 and 60000. 0 indicates that SYNC is disabled.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="configuration" dataType="OpcUa_UInt32" name="nodeGuardIntervalMs" nullPolicy="nullForbidden" addressSpaceWrite="delegated">
      <d:configRestriction>
        <d:restrictionByBounds minInclusive="2000"/>  
      </d:configRestriction>
      <d:documentation>
        The NG interval in miliseconds for all nodes configured for NodeGuarding. 10000 is a typical value.
        <b>It must be higher than the nodeGuardingReplyTimeout from GlobalSettings.</b>
      </d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="statsTotalTransmitted" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>
        Number of CAN frames transmitted by the server in the observation period.
      </d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="statsTotalReceived" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>
        Number of CAN frames received by the server in the observation period.
      </d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Double" name="statsTxRate" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>TX rate in frames/sec.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Double" name="statsRxRate" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>RX rate in frames/sec.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="statsTransitionsIntoErrorCounter" nullPolicy="nullForbidden" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good" initialValue="0">
      <d:documentation>How many times this bus went into error state?</d:documentation>
    </d:cachevariable>
  </d:class>
  <d:class name="Node">
    <d:devicelogic>
      <d:mutex/>
    </d:devicelogic>
    <d:configentry dataType="OpcUa_Byte" name="id" isKey="true" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByBounds minInclusive="1"/>
      </d:configRestriction>
      <d:documentation>CANopen node id. Typically configured by switches or jumpers on the actual hardware.</d:documentation>
    </d:configentry>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="bootupCounter" nullPolicy="nullForbidden" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good" initialValue="0">
      <d:documentation>Number of bootup messages that the server from the node since server's start-up.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="state" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>CANopen state of the node understood as what node-guarding returns (toggling is not filtered out).</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="stateNoToggle" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>State with the toggle bit filtered out.</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaString" name="stateAsText" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>CANopen state, enhanced with DISCONNECTED and UNKNOWN state, shown as text, one of:
			<ul><li>STOPPED - online but intentionally stopped. Not replying to SDOs and PDOs.</li><li>PREOPERATIONAL - preoperational. Replying to SDOs but not performing any PDO info exchange.</li><li>OPERATIONAL - in full operation</li><li>DISCONNECTED - node not responding while the server believes that the infrastructure (especially the CAN interface) is alright</li><li>UNKNOWN - the state is not known due to identified issues, e.g. CAN interface down or so.</li></ul>
			</d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="configuration" dataType="UaString" name="requestedState" nullPolicy="nullForbidden" addressSpaceWrite="delegated">
      <d:documentation>
			Specifies the intended state of a node. Is applicable both for configuration (then it specifies the initial state that the node should be brought into)
			as well as in the usual runtime (then it can be used to control the state).
			</d:documentation>
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="OPERATIONAL"/>
          <d:enumerationValue value="PREOPERATIONAL"/>
          <d:enumerationValue value="STOPPED"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:cachevariable>
    <d:method name="reset" executionSynchronicity="asynchronous" addressSpaceCallUseMutex="of_containing_object">
      <d:returnvalue dataType="OpcUa_Boolean" name="bootupReceived"/>
      <d:documentation>
    		Attempts node reset by sending NMT request. Will return success if the node replied within
    		bootup message. Otherwise will fail.
    	</d:documentation>
    </d:method>
    <d:hasobjects instantiateUsing="configuration" class="Tpdo"/>
    <d:hasobjects instantiateUsing="configuration" class="TpdoMultiplex"/>
    <d:hasobjects instantiateUsing="configuration" class="Rpdo"/>
    <d:hasobjects instantiateUsing="configuration" class="SdoSameIndexGroup"/>
    <d:hasobjects instantiateUsing="configuration" class="SdoVariable"/>
    <d:hasobjects instantiateUsing="design" class="EmergencyParser">
      <d:object name="Emergency"/>
    </d:hasobjects>
    <d:hasobjects instantiateUsing="configuration" class="OnlineConfigValidator" maxOccurs="1"/>
    <d:hasobjects instantiateUsing="configuration" class="SdoValidator"/>
    <d:configentry dataType="UaString" name="stateInfoSource" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="NodeGuard"/>
          <d:enumerationValue value="HeartBeat"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="stateToggleViolationCounter" nullPolicy="nullForbidden" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good" initialValue="0">
      <d:documentation>Increments every time a state violation happens, which helps to identify ELMBs with firmware or connectivity issues.</d:documentation>
    </d:cachevariable>
    <d:configentry dataType="UaString" name="emergencyMappingModel" defaultValue="ELMBio">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="ELMBio">
            <d:documentation>Try to parse the emergency using the ELMBio model first, then fall back to CANopen model if necessary.</d:documentation>
          </d:enumerationValue>
          <d:enumerationValue value="CANopen">
            <d:documentation>Parse the emergency messages using the generic CANopen model only.</d:documentation>
          </d:enumerationValue>
          <d:enumerationValue value="None">
            <d:documentation>Do not parse the emergency messages at all (does not publish anything in the <code>lastErrorDescription</code>).</d:documentation>
          </d:enumerationValue>
        </d:restrictionByEnumeration>
      </d:configRestriction>
      <d:documentation>How to parse the emergency objects into their human-readable description?</d:documentation>
    </d:configentry>
    <d:sourcevariable dataType="OpcUa_UInt32" name="nmtPartialBackwardsCompat" addressSpaceRead="forbidden" addressSpaceReadUseMutex="no" addressSpaceWrite="asynchronous" addressSpaceWriteUseMutex="of_containing_object">
      <d:documentation>This variable is for ensuring *partial compatibility* with the Slava's CANopen OPCUA server -- see FN4.1 in the Piotr's writeup for docs.</d:documentation>
    </d:sourcevariable>
    <d:configentry name="hasSdoSupport" dataType="OpcUa_Boolean" defaultValue="true">
      <d:documentation>
        Some CANopen devices intentionally do not support SDO service. This is rare (and possibly breaks the standard)
        but it happens. You can use this setting to flag such a node.
      </d:documentation>
    </d:configentry>
    <d:documentation>
      This class corresponds to a CANopen node. <i>Standard ELMB example: one object of this class corresponds to one ELMB.</i>
    </d:documentation>
  </d:class>
  <d:class name="EmergencyParser">
    <d:devicelogic/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt16" name="lastErrorCode" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaString" name="lastErrorDescription" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>
        Human-readable description of the last emergency error, depending on the chosen emergency mapping model.
      </d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorRegister" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte3" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte4" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte5" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte6" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_Byte" name="lastErrorByte7" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData"/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="emergencyErrorCounter" nullPolicy="nullForbidden" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good" initialValue="0">
      <d:documentation>
        Increments on every emergency message received from the node.
      </d:documentation>
    </d:cachevariable>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaString" name="lastEmergencyErrorBundle" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData" initialValue="">
      <d:documentation>
        A string representation of the whole emergency object. For example <verbatim>0x5000|90|1|2c|0|0|80|</verbatim>.
      </d:documentation>
    </d:cachevariable>
  </d:class>
  <d:class name="Tpdo">
    <d:devicelogic>
      <d:mutex/>
    </d:devicelogic>
    <d:hasobjects instantiateUsing="configuration" class="ExtractedValue"/>
    <d:configentry dataType="UaString" name="selector" isKey="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="1|2|3|4|base_cobid:0x[0-9A-F]{1,3}" />
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="transportMechanism">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="sync">
            <d:documentation>Node emits a PDO after every SYNC request.</d:documentation>
          </d:enumerationValue>
          <d:enumerationValue value="asyncSupportsRtr">
            <d:documentation>Node emits a PDO when it wants. RTR can be requested from the address space to provoke it.</d:documentation>
          </d:enumerationValue>
          <d:enumerationValue value="asyncPeriodicRtrWithRequests">
            <d:documentation>Node emits a PDO when it wants. RTR is emitted periodically by the server (see GlobalSettings) and it can also be requested from the address space.</d:documentation>
          </d:enumerationValue>
          <d:enumerationValue value="publieCommeRecu">
            <d:documentation>Not implemented.</d:documentation>
          </d:enumerationValue>
        </d:restrictionByEnumeration>
      </d:configRestriction>
      <d:documentation>What triggers the PDO?</d:documentation>
    </d:configentry>
    <d:sourcevariable dataType="OpcUa_UInt32" name="invokeRtr" addressSpaceRead="asynchronous" addressSpaceReadUseMutex="of_containing_object" addressSpaceWrite="asynchronous" addressSpaceWriteUseMutex="of_containing_object">
      <d:documentation>Writing to this variable invokes the RTR for this TPDO. It is a compatibility mode for WinCC OA which can not do method calls. Reading from this variable returns number of times the RTR was invoked in this way.</d:documentation>
    </d:sourcevariable>
    <d:documentation>Corresponds to one non-multiplexed TPDO object.</d:documentation>
  </d:class>
  <d:class name="TpdoMultiplex">
    <d:devicelogic/>
    <d:configentry dataType="UaString" name="selector" isKey="true">
      <d:documentation>
  			The selector code of the TPDO, for TPDO3 it should be 3,
  			etc.
  		</d:documentation>
      <d:configRestriction>
        <d:restrictionByPattern pattern="1|2|3|4|base_cobid:0x[0-9A-F]{1,3}" />
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="transportMechanism" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="sync"/>
          <d:enumerationValue value="asyncWithRtr"/>
          <d:enumerationValue value="publieCommeRecu"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:hasobjects instantiateUsing="configuration" class="MultiplexedChannel"/>
    <d:hasobjects instantiateUsing="configuration" class="MultiplexedChannelConfigurationGenerator"/>
  </d:class>
  <d:class name="Rpdo">
    <d:devicelogic>
      <d:mutex/>
    </d:devicelogic>
    <d:configentry dataType="UaString" name="selector" isKey="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="1|2|3|4|base_cobid:0x[0-9A-F]{1,3}" />
      </d:configRestriction>
      <d:documentation>
            The selector code of the RPDO, for RPDO1 it should be 1,
            etc.
        </d:documentation>
    </d:configentry>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaByteString" name="cache" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_Good">
      <d:documentation>Presents current cached value of the Rpdo as the whole CANopen communication object. Primary use is debugging.</d:documentation>
    </d:cachevariable>
    <d:hasobjects instantiateUsing="configuration" class="RpdoCachedVariable"/>
  </d:class>
  <d:class name="RpdoCachedVariable" singleVariableNode="true">
    <d:devicelogic/>
    <d:sourcevariable dataType="UaVariant" name="value" addressSpaceRead="asynchronous" addressSpaceReadUseMutex="of_parent_of_containing_object" addressSpaceWrite="asynchronous" addressSpaceWriteUseMutex="of_parent_of_containing_object">
  	</d:sourcevariable>
    <d:configentry dataType="UaString" name="dataType" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="Boolean"/>
          <d:enumerationValue value="Byte"/>
          <d:enumerationValue value="UInt16"/>
          <d:enumerationValue value="Int16"/>
          <d:enumerationValue value="UInt32"/>
          <d:enumerationValue value="Int32"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="OpcUa_Byte" name="offset" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByBounds maxInclusive="7"/>
      </d:configRestriction>
      <d:documentation>
  			Position in the RPDO payload to be sent at which this variable is mapped.
  		</d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Byte" name="booleanToBit" storedInDeviceObject="true" defaultValue="0">
      <d:configRestriction>
        <d:restrictionByBounds maxInclusive="7"/>
      </d:configRestriction>
      <d:documentation>If Boolean, specifies to which bit the boolean applies</d:documentation>
    </d:configentry>
  </d:class>
  <d:class name="OnlineConfigValidator">
    <d:devicelogic/>
    <d:hasobjects instantiateUsing="configuration" class="SdoValidator"/>
    <d:method name="validate" executionSynchronicity="asynchronous">
      <d:returnvalue dataType="UaString" name="details">
        <d:array/>
      </d:returnvalue>
      <d:returnvalue dataType="OpcUa_Boolean" name="passed"/><d:returnvalue dataType="OpcUa_UInt32"
      	name="numberOfFailures">
</d:returnvalue>
    </d:method>
    <d:cachevariable initializeWith="valueAndStatus" dataType="OpcUa_UInt32" name="failuresNumberLastRun"
    	nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
      <d:documentation>Presents the number of failures experienced in the last run of the validator. Can be used to set an alert on it.</d:documentation>
    </d:cachevariable>
  </d:class>
  <d:class name="MultiplexedChannel">
    <d:devicelogic/>
    <d:configentry dataType="OpcUa_UInt16" name="id" isKey="true">
      <d:documentation>
        CANopen node ID of the node.
      </d:documentation>
    </d:configentry>
    <d:hasobjects instantiateUsing="configuration" class="ExtractedValue"/>
    <d:documentation>
      A channel that is read-out using multiplexed TPDO. <i>Standard ELMB example: all analog input channels are multiplexed using TPDO3.</i>
    </d:documentation>
  </d:class>
  <d:class name="ExtractedValue" singleVariableNode="true">
    <d:devicelogic/>
    <d:cachevariable initializeWith="valueAndStatus" dataType="UaVariant" name="value" nullPolicy="nullAllowed" addressSpaceWrite="forbidden" initialStatus="OpcUa_BadWaitingForInitialData">
  	  <d:documentation>
        Value extracted from CAN frame is placed here. 
      </d:documentation>
    </d:cachevariable>
    <d:configentry dataType="UaString" name="dataType" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="Boolean"/>
          <d:enumerationValue value="Byte"/>
          <d:enumerationValue value="UInt16"/>
          <d:enumerationValue value="UInt32"/>
          <d:enumerationValue value="Int16"/>
          <d:enumerationValue value="Int32"/>
          <d:enumerationValue value="Float"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
      <d:documentation>
        DataType which should be used to interprete received data.
      </d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Byte" name="offset" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByBounds maxInclusive="7"/>
      </d:configRestriction>
      <d:documentation>
  			At which octet in the data of the received TPDO frame this
  			value starts?
  		</d:documentation>
    </d:configentry>
    <d:configentry dataType="UaString" name="booleanFromBit" defaultValue="-" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="0|1|2|3|4|5|6|7|-"/>
      </d:configRestriction>
      <d:documentation>
        When extracting a boolean, you can specify a particular bit from the byte taken into the consideration.
        The default value of "-" will perform boolean comprehension as in the C programming language, i.e. zero will be false, non-zero true.
      </d:documentation>
    </d:configentry>
    <d:documentation>
      ExtractedValue is used to map fields of TPDOs and multiplexed TPDOs to actual variables, thus providing a bridge between chosen TPDO structure and its address-space counterpart.
    </d:documentation>
  </d:class>
  <d:class name="MultiplexedChannelConfigurationGenerator">
    <d:hasobjects instantiateUsing="configuration" class="MultiplexedChannel"/>
    <d:configentry dataType="OpcUa_Byte" name="numberOfChannels">
      <d:documentation>
        How many identical channels should be configured in this multiplex?
      </d:documentation>
    </d:configentry>
    <d:documentation>
      This class models only the configuration generator for multiplex -- it vanishes for runtime.
    </d:documentation>
  </d:class>
  <d:class name="SdoSameIndexGroup">
    <d:devicelogic/>
    <d:hasobjects instantiateUsing="configuration" class="SdoVariable"/>
    <d:configentry dataType="UaString" name="index">
      <d:configRestriction>
        <d:restrictionByPattern pattern="[0-9A-F]{1,4}"/>
      </d:configRestriction>
    </d:configentry>
    <d:documentation>Convenience class to group all SDOs with the same object index.</d:documentation>
  </d:class>
  <d:class name="SdoVariable" singleVariableNode="true">
    <d:devicelogic/>
    <d:configentry dataType="UaString" name="index" defaultValue="fromGroup" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="fromGroup|[0-9A-F]{1,4}"/>
      </d:configRestriction>
      <d:documentation>
        For an independent declaration (i.e. the SdoVariable instantiated directly under Node), it is the SDO index of the variable <emph>in hexadecimal</emph>
        (e.g. 100D in this config entry, corresponding to 4109 decimal, would map to heart-beat life-time of a typical CANopen node). 
        For a declaration under SdoSameIndexGroup, it can be skipped or the default of "fromGroup" can be used.
      </d:documentation>
    </d:configentry>
    <d:configentry dataType="OpcUa_Byte" name="subIndex">
      <d:documentation>
        SDO subIndex, compulsory for all cases. In contrast to the SDO index, this one is <emph>in decimal</emph> format.
      </d:documentation>
    </d:configentry>
    <d:configentry dataType="UaString" name="dataType" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="Boolean"/>
          <d:enumerationValue value="Byte"/>
          <d:enumerationValue value="UInt16"/>
          <d:enumerationValue value="UInt32"/>
          <d:enumerationValue value="Int32"/>
        </d:restrictionByEnumeration>
      </d:configRestriction>
    </d:configentry>
    <d:configentry dataType="UaString" name="access" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByEnumeration>
          <d:enumerationValue value="R"><d:documentation>The server permitts reading from a CANopen node only (i.e. Domain Upload in CANopen parlance).</d:documentation></d:enumerationValue>
          <d:enumerationValue value="RW"><d:documentation>The server permitts reading and writing from/to a CANopen node (i.e. both Domain Upload and Download in CANopen parlance).</d:documentation></d:enumerationValue>
          <d:enumerationValue value="W"><d:documentation>The server permitts writing to a CANopen node only (i.e. Domain Download in CANopen parlance).</d:documentation></d:enumerationValue>
        </d:restrictionByEnumeration>
      </d:configRestriction>
      <d:documentation>Which direction of data flow is permitted?</d:documentation>
    </d:configentry>
    <d:configentry dataType="UaString" name="booleanFromBit" defaultValue="-" storedInDeviceObject="true">
      <d:configRestriction>
        <d:restrictionByPattern pattern="0|1|2|3|4|5|6|7|-"/>
      </d:configRestriction>
    </d:configentry>
    <d:configentry name="expeditedSdoReadTimeoutSeconds" dataType="UaString" defaultValue="inheritGlobal">
      <d:configRestriction>
        <d:restrictionByPattern pattern="inheritGlobal|[0-9]?[1-9]+" />
      </d:configRestriction>
      <d:documentation>
        How much time is given for expedited SDO read until it timeouts?
        The special value inheritGlobal (which is also the default) signifies that the value from globalSettings is to be used.
      </d:documentation>
    </d:configentry>
    <d:configentry name="expeditedSdoWriteTimeoutSeconds" dataType="UaString" defaultValue="inheritGlobal">
      <d:configRestriction>
        <d:restrictionByPattern pattern="inheritGlobal|[0-9]?[1-9]+" />
      </d:configRestriction>
      <d:documentation>
        How much time is given for expedited SDO write until it timeouts?
        The special value inheritGlobal (which is also the default) signifies that the value from globalSettings is to be used.
      </d:documentation>
    </d:configentry>
    <d:sourcevariable dataType="UaVariant" name="value" addressSpaceRead="asynchronous" addressSpaceReadUseMutex="no" addressSpaceWrite="asynchronous" addressSpaceWriteUseMutex="no"/>
    <d:documentation>A variable that corresponds to one object dictionary entry.</d:documentation>
  </d:class>
  <d:class name="SdoValidator">
    <d:devicelogic/>
    <d:method name="validate" executionSynchronicity="asynchronous">
      <d:returnvalue dataType="OpcUa_Boolean" name="passed"/>
    </d:method>
    <d:configentry dataType="UaString" name="assertTrueFormula" storedInDeviceObject="true"/>
    <d:configentry name="description" dataType="UaString" storedInDeviceObject="true"/>
  </d:class>
  <d:root>
    <d:hasobjects instantiateUsing="configuration" class="GlobalSettings" maxOccurs="1" minOccurs="1"/>
    <d:hasobjects instantiateUsing="configuration" class="Warnings" maxOccurs="1" minOccurs="1"/>
    <d:hasobjects class="Meta" instantiateUsing="design" minOccurs="1" maxOccurs="1">
      <d:object name="Meta" />
    </d:hasobjects>
    <d:hasobjects instantiateUsing="configuration" class="Bus"/>
  </d:root>
</d:design>
