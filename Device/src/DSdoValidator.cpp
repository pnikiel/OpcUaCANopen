
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DSdoValidator.h>
#include <ASSdoValidator.h>
#include <DNode.h>
#include <DSdoVariable.h>

#include <Logging.hpp>

using namespace Logging;

namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DSdoValidator::DSdoValidator (
    const Configuration::SdoValidator& config,
    Parent_DSdoValidator* parent
):
    Base_DSdoValidator( config, parent),
    m_node(nullptr)

    /* fill up constructor initialization list here */
{
    /* fill up constructor body here */
    m_parser.DefineNameChars("0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.");
    m_parser.SetExpr(config.assertTrueFormula());
    
}

/* sample dtr */
DSdoValidator::~DSdoValidator ()
{
}

/* delegates for cachevariables */



/* delegators for methods */
UaStatus DSdoValidator::callValidate (
    OpcUa_Boolean& passed
)
{
    this->validate();
    passed = OpcUa_False; // TODO
    return OpcUa_BadNotImplemented;
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333

void DSdoValidator::initialize(DNode* node)
{
    m_node = node;
    auto usedVariables = m_parser.GetUsedVar();
    LOG(Log::INF, "SdoValidator") << wrapId(getFullName()) << " recognized these operands:";
    for (auto& x : usedVariables)
    {
        // check if we're dealing with a constant?
        LOG(Log::INF, "SdoValidator") << "name: " << x.first; // no sense to print the value as it is not initialized yet
        // if (Engine::isConstantDefined(x.first))
        // {
        //     double value = Engine::getValueOfConstant(x.first);
        //     LOG(Log::TRC, logComponentId) << "Recognized use of constant, name: " << x.first << " value: " << value;
        //     parser.DefineConst(x.first, value);
        // }
    }
    // try
    // {
    //     m_parser.Eval();
    // }
    // catch(const mu::Parser::exception_type &e)
    // {
    //     std::cerr << e.GetMsg() << '\n';
    // }


}

void DSdoValidator::validate()
{
    /* This is the actual validation */
    /* Need to supply values of the variables that are used */
        auto usedVariables = m_parser.GetUsedVar();
    LOG(Log::INF, "SdoValidator") << wrapId(getFullName()) << " recognized these operands:";
    for (auto& x : usedVariables)
    {
        // check if we're dealing with a constant?
        LOG(Log::INF, "SdoValidator") << wrapId(getFullName()) << " will query SDO named " << x.first; // no sense to print the value as it is not initialized yet
        // if (Engine::isConstantDefined(x.first))
        // {
        //     double value = Engine::getValueOfConstant(x.first);
        //     LOG(Log::TRC, logComponentId) << "Recognized use of constant, name: " << x.first << " value: " << value;
        //     parser.DefineConst(x.first, value);
        // }

        DSdoVariable* sdoVariable = m_node->getSdoByShortName(x.first); // TODO: protection for not having this short name
        
        // try to obtain the value
        UaVariant sdoValueRead;
        UaDateTime sourceTime;
        sdoVariable->readValue(sdoValueRead, sourceTime);
        LOG(Log::INF, "SdoValidator") << wrapId(getFullName()) << " read SDO " << wrapValue(x.first) << " value obtained is " << wrapId(sdoValueRead.toString().toUtf8());

        double value;
        sdoValueRead.toDouble(value); // TODO: this might fail or there might be an inconsistency for the data types

        LOG(Log::INF, "SdoValidator") << value;

        m_parser.DefineConst(x.first, value);

    }

    LOG(Log::INF, "SdoValidator") << wrapId(getFullName()) << " will try to evaluate now";

    try
    {
        double evaluation = m_parser.Eval();
        LOG(Log::INF, "SdoValidator") << wrapId(getFullName()) << " validation value: " << wrapValue(std::to_string(evaluation));
    }
    catch(const mu::Parser::exception_type &e)
    {
        std::cerr << e.GetMsg() << '\n';
        LOG(Log::ERR, "SdoValidator") << wrapId(getFullName()) << " validation error: " << e.GetMsg();
    }
    

}

}