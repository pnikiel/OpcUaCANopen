
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DStateSwitcher.h>
#include <ASStateSwitcher.h>
#include <DRoot.h>
#include <DBus.h>
#include <DNode.h>


#include <boost/regex.hpp>

namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DStateSwitcher::DStateSwitcher (
    const Configuration::StateSwitcher& config,
    Parent_DStateSwitcher* parent
):
    Base_DStateSwitcher( config, parent)

    /* fill up constructor initialization list here */
{
    /* fill up constructor body here */
}

/* sample dtr */
DStateSwitcher::~DStateSwitcher ()
{
}

/* delegates for cachevariables */



/* delegators for methods */
UaStatus DStateSwitcher::callGoToPreOperational (
    const UaString&  nodeNamePattern,
    UaString& info,
    std::vector<UaString>& affectedNodes
)
{
    try
    {
        this->requestSwitch(nodeNamePattern.toUtf8(), CANopen::NodeState::PREOPERATIONAL, &affectedNodes);
        info = UaString("PREOP requestedState applied to ") + std::to_string(affectedNodes.size()).c_str() + " nodes";
        return OpcUa_Good;
    }
    catch (const std::exception& e)
    {
        info = UaString("Fail: ") + e.what();
        return OpcUa_Bad;
    }
}

UaStatus DStateSwitcher::callGoToOperational (
    const UaString&  nodeNamePattern,
    UaString& info,
    std::vector<UaString>& affectedNodes
)
{
    try
    {
        this->requestSwitch(nodeNamePattern.toUtf8(), CANopen::NodeState::OPERATIONAL, &affectedNodes);
        info = UaString("OP requestedState applied to ") + std::to_string(affectedNodes.size()).c_str() + " nodes";
        return OpcUa_Good;
    }
    catch (const std::exception& e)
    {
        info = UaString("Fail: ") + e.what();
        return OpcUa_Bad;
    }
}

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333

void DStateSwitcher::requestSwitch(
    const std::string& pattern,
    CANopen::NodeState intendedState,
    std::vector<UaString>* affectedNodes )
{
    std::string nodeNamePatternStr (pattern);
    if (nodeNamePatternStr == "")
        nodeNamePatternStr = ".*";
    else
    {
        /* string replace - * to .* - to use the common vanilla asterisk pattern search */
        size_t index = 0;
        while (true)
        {
            index = nodeNamePatternStr.find("*", index);
            if (index == std::string::npos) break;
            nodeNamePatternStr.replace(index, 1, ".*");
            index += 2;
        }
    }

    boost::regex re (nodeNamePatternStr);

    for (auto bus : Device::DRoot::getInstance()->buss())
    {
        for (auto node : bus->nodes())
        {
            boost::smatch matchResults;
            bool matched = boost::regex_match( node->getFullName(), matchResults, re );
            if (matched)
            {
                node->requestState(intendedState);
                if (affectedNodes)
                    affectedNodes->push_back(node->getFullName().c_str() );
            }
        }
    }
}

}